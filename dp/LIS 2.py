'''
https://www.acmicpc.net/problem/2631

이 문제는 어렵고 나중에 어떤 형식으로 희석될 지 모르겠다.
 - 우선 지금 문제를 풀 때 집중한 부분은
 - 한 상황에서 그 앞까지 dp 원소 중에 가장 큰 값에서 이어붙이면 현재 원소를 포함한 가장 긴 부분 수열의 길이가 되지 않을까?
 - 그리고 그 원소들이 증가된 채로 위 과정을 수행하면 증가하는 부분 수열이 되지 않을까?

문제 이해
 - 당연히, N번의 작업으로 순서대로 배치할 수 있다.
 - 각 원소의 값이 인덱스를 의미하므로, 가장 큰 값부터 맨 앞으로 옮기면 순서대로 배치할 수 있다.
 - 최소로 움직이기 위해서는 움직이려는 값의 앞부분과 움직이고 난 후의 뒤까지가 인덱스가 하나씩 추가되는 점을 이용하면 될 거 같다.
 -

이거 그리디는 안돼
브루트 포스? 머리 총 맞은 짓이야
상태를 저장해야한다. -> 즉 dp다

3 7 5 2 6 1 4 -> 2
2 3 7 5 6 1 4 -> 1
1 2 3 7 5 6 4 -> 4
1 2 3 4 7 5 6 -> 7
1 2 3 4 5 6 7

3 7 5 2 6 1 4 -> 5
3 7 2 6 1 4 5 -> 6
3 7 2 1 4 5 6 -> 7
3 2 1 4 5 6 7 -> 2
2 3 1 4 5 6 7 -> 1
1 2 3 4 5 6 7

위 두 공통 로직은 앞(혹은 뒤)부터 자신의 자리가 아니라면 하나 앞(혹은 뒤)를 불러오는 것이다.
'''
N = int(input())
line = [int(input()) for _ in range(N)]

dp = [1 for _ in range(1, N+1)]
for i in range(N):
    for j in range(i):
        if line[j] < line[i]:
            dp[i] = max(dp[i], dp[j]+1)
long_subsequence = max(dp)
print(N-long_subsequence)
